# V2 Plan: Google Login + Supabase Database

This document outlines how to add Google authentication via Supabase and move prompt data from in‑memory storage to Supabase Postgres with RLS.

## Overview

- Auth: Supabase Auth with Google OAuth.
- Data: Supabase Postgres for categories, prompts, and saved prompts.
- Client: Uses Supabase JS for login + direct CRUD (protected by RLS).
- Server (optional): Verify JWT and/or write via service role, keeping AI routes intact.

## Supabase Setup

1) Create a Supabase project
- Note `SUPABASE_URL`, `SUPABASE_ANON_KEY`, and `SUPABASE_SERVICE_ROLE_KEY`.

2) Enable Google provider
- In Google Cloud → OAuth client (Web), set Authorized redirect URIs:
  - Local: `http://localhost:5000/`
  - Vercel prod: `https://YOUR-VERCEL-DOMAIN.vercel.app/`
  - Vercel preview: `https://*.vercel.app/`
- Paste Client ID/Secret into Supabase → Auth → Providers → Google.

## Database Schema

Tables compatible with the current app’s models.

```
create extension if not exists "uuid-ossp";

create table if not exists categories (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  icon text not null,
  color text not null,
  description text
);

create table if not exists prompts (
  id uuid primary key default uuid_generate_v4(),
  title text not null,
  description text not null,
  content text not null,
  category_id uuid references categories(id) not null,
  is_featured boolean default false,
  views int default 0,
  likes int default 0,
  owner_id uuid references auth.users(id),
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists saved_prompts (
  id uuid primary key default uuid_generate_v4(),
  prompt_id uuid references prompts(id) not null,
  user_id uuid references auth.users(id) not null,
  created_at timestamptz default now()
);
```

Row Level Security (RLS):

```
alter table prompts enable row level security;
alter table saved_prompts enable row level security;

-- Everyone can read prompts
create policy "read_prompts" on prompts
  for select using (true);

-- Only owner can insert/update their own prompts
create policy "insert_prompts" on prompts
  for insert with check (auth.uid() = owner_id);
create policy "update_own_prompts" on prompts
  for update using (auth.uid() = owner_id);

-- Saved prompts: user can read/write own
create policy "read_saved_prompts" on saved_prompts
  for select using (auth.uid() = user_id);
create policy "insert_saved_prompts" on saved_prompts
  for insert with check (auth.uid() = user_id);
create policy "delete_saved_prompts" on saved_prompts
  for delete using (auth.uid() = user_id);
```

## Client Integration

Install:

```
npm i @supabase/supabase-js
```

Create Supabase client (client/src/lib/supabase.ts):

```ts
import { createClient } from '@supabase/supabase-js';
export const supabase = createClient(
  import.meta.env.VITE_SUPABASE_URL!,
  import.meta.env.VITE_SUPABASE_ANON_KEY!
);
```

Simple auth helpers (client/src/lib/auth.ts):

```ts
import { supabase } from './supabase';
export const signInWithGoogle = () =>
  supabase.auth.signInWithOAuth({
    provider: 'google',
    options: { redirectTo: window.location.origin },
  });
export const signOut = () => supabase.auth.signOut();
```

Add login/logout to the nav (show session info if present). Use `supabase.auth.getSession()` and `onAuthStateChange` to track state.

Data access examples (replace current fetches progressively):

```ts
// Categories
await supabase.from('categories').select('*').order('name');

// Prompts: list, filter
await supabase.from('prompts').select('*, category:categories(*)');
await supabase.from('prompts').select('*').eq('category_id', someId);

// Prompts: create (must set owner_id)
await supabase.from('prompts').insert({
  title, description, content, category_id, owner_id: session.user.id
});

// Saved prompts: list for user
await supabase
  .from('saved_prompts')
  .select('prompt:prompts(*, category:categories(*))')
  .eq('user_id', session.user.id);

// Save / Unsave
await supabase.from('saved_prompts').insert({ prompt_id, user_id: session.user.id });
await supabase.from('saved_prompts').delete().match({ prompt_id, user_id: session.user.id });
```

Optionally attach the Supabase JWT when calling your Node API endpoints:

```ts
const token = (await supabase.auth.getSession()).data.session?.access_token;
fetch('/api/your-endpoint', { headers: { Authorization: `Bearer ${token}` } });
```

## Server Integration (Optional)

If you prefer the Node API to mediate all writes:

- Install `@supabase/supabase-js` on the server.
- Create an admin client with service-role key and verify incoming JWTs.
- Implement `SupabaseStorage` conforming to `IStorage` and export it instead of `MemStorage` in production.

```ts
import { createClient } from '@supabase/supabase-js';
const supabase = createClient(process.env.SUPABASE_URL!, process.env.SUPABASE_SERVICE_ROLE_KEY!);
// Verify token from Authorization header with supabase.auth.getUser(token)
```

## Environment Variables

Vercel → Project Settings → Environment Variables

Client (public):
- `VITE_SUPABASE_URL`
- `VITE_SUPABASE_ANON_KEY`

Server (private):
- `SUPABASE_URL` (same as VITE_SUPABASE_URL)
- `SUPABASE_SERVICE_ROLE_KEY` (server-only)
- Existing AI vars: `OPENAI_API_KEY` (+ optional `OPENAI_MODEL`, `OPENAI_TEMPERATURE`)

Do not set `PORT` on Vercel.

## Redirects

- Google redirect URIs must include:
  - `http://localhost:5000/`
  - `https://YOUR-VERCEL-DOMAIN.vercel.app/`
  - `https://*.vercel.app/` (for previews)

## Migration Plan

- Phase 1: Keep AI routes on Node; move client reads/writes to Supabase via RLS.
- Phase 2 (optional): Move server storage to Supabase and enforce auth on the API.

## Next Steps

- Add the Supabase client and auth buttons.
- Create SQL tables + RLS policies in Supabase.
- Swap client data fetches incrementally to Supabase.
- (Optional) Add server JWT verification and adopt `SupabaseStorage`.
